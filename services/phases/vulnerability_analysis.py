# autosentou/services/phases/vulnerability_analysis.py
import json
import re
from datetime import datetime
from typing import Dict, Any, List, Optional
from autosentou.services.utils.system import run_command
from autosentou.services.utils.cve_lookup import cve_db
from autosentou.models import Phase, Job


def identify_services_vulnerabilities(services_data: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Identify potential vulnerabilities based on service information from nmap.
    Uses real CVE database lookup.
    """
    vulnerabilities = []
    
    for service in services_data.get('parsed_ports', []):
        port = service.get('port')
        service_name = service.get('service', '').lower()
        version = service.get('version', '').lower()
        state = service.get('state', '')
        
        # Only check open ports
        if state != 'open':
            continue
        
        # Skip if no service identified
        if not service_name or service_name in ['unknown', 'tcpwrapped']:
            continue
        
        print(f"Checking vulnerabilities for {service_name} {version} on port {port}")
        
        # Look up vulnerabilities using CVE database
        cve_vulnerabilities = cve_db.lookup_service_vulnerabilities(service_name, version)
        
        for vuln in cve_vulnerabilities:
            vulnerabilities.append({
                'service': service_name,
                'version': version,
                'port': port,
                'vulnerability_type': vuln.get('description', 'Unknown vulnerability'),
                'severity': vuln.get('severity', 'Unknown'),
                'description': vuln.get('description', ''),
                'cve_references': [vuln.get('cve_id', '')],
                'cvss_score': vuln.get('cvss_score', 0.0),
                'cvss_vector': vuln.get('cvss_vector', ''),
                'poc_available': False,  # Will be determined later
                'version_affected': vuln.get('version_affected', True),
                'published_date': vuln.get('published_date', ''),
                'source': vuln.get('source', 'Unknown')
            })
    
    return vulnerabilities


def run_cve_analysis(services_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Run CVE analysis on identified services using real CVE database.
    """
    vulnerabilities = identify_services_vulnerabilities(services_data)
    
    # Get exploit information for each vulnerability
    cve_results = []
    for vuln in vulnerabilities:
        # Get exploit info for each CVE
        exploit_info = {}
        if vuln.get('cve_references'):
            cve_id = vuln['cve_references'][0]
            if cve_id:
                exploit_info = cve_db.get_exploit_info(cve_id)
        
        cve_results.append({
            **vuln,
            'poc_available': exploit_info.get('poc_available', False),
            'exploit_difficulty': exploit_info.get('exploit_difficulty', 'Unknown'),
            'exploit_url': exploit_info.get('exploit_url', ''),
        })
    
    # Count vulnerabilities by severity
    severity_counts = {
        'critical': len([v for v in cve_results if v.get('severity') == 'Critical']),
        'high': len([v for v in cve_results if v.get('severity') == 'High']),
        'medium': len([v for v in cve_results if v.get('severity') == 'Medium']),
        'low': len([v for v in cve_results if v.get('severity') == 'Low']),
        'unknown': len([v for v in cve_results if v.get('severity') == 'Unknown'])
    }
    
    return {
        'vulnerabilities': cve_results,
        'total_vulns': len(cve_results),
        'severity_counts': severity_counts,
        'critical_severity': severity_counts['critical'],
        'high_severity': severity_counts['high'],
        'medium_severity': severity_counts['medium'],
        'low_severity': severity_counts['low'],
        'unknown_severity': severity_counts['unknown'],
        'analysis_timestamp': datetime.utcnow().isoformat()
    }


def run_poc_execution(vulnerabilities: List[Dict[str, Any]], target: str) -> Dict[str, Any]:
    """
    Execute Proof of Concept tests for identified vulnerabilities.
    This is a simplified version - in production, you'd have actual PoC execution.
    """
    poc_results = []
    
    for vuln in vulnerabilities:
        if vuln.get('poc_available'):
            # Simulate PoC execution
            poc_result = {
                'vulnerability_id': vuln.get('cve_references', [None])[0],
                'service': vuln.get('service'),
                'port': vuln.get('port'),
                'poc_status': 'simulated',  # Would be 'success', 'failed', 'not_applicable'
                'poc_output': f"Simulated PoC execution for {vuln.get('service')} on port {vuln.get('port')}",
                'exploit_successful': False,  # Would be determined by actual PoC
                'notes': 'This is a simulated PoC execution for demonstration purposes',
            }
            poc_results.append(poc_result)
    
    return {
        'poc_results': poc_results,
        'total_pocs': len(poc_results),
        'successful_pocs': len([p for p in poc_results if p.get('exploit_successful')]),
    }


def run_vulnerability_analysis_phase(db_session, job: Job, info_gathering_data: Dict[str, Any]) -> Optional[Phase]:
    """
    Run vulnerability analysis phase including CVE mapping and PoC execution.
    """
    phase = Phase(
        job_id=job.id,
        phase_name="Vulnerability Analysis",
        data={},
        log_path=None,
        status="ongoing",
    )
    db_session.add(phase)
    db_session.commit()
    db_session.refresh(phase)

    try:
        print("Starting vulnerability analysis...")
        
        # Extract services from info gathering phase
        nmap_data = info_gathering_data.get('nmap', {})
        
        # Run CVE analysis
        cve_analysis = run_cve_analysis(nmap_data)
        
        # Run PoC execution
        poc_results = run_poc_execution(cve_analysis['vulnerabilities'], job.target)
        
        # Combine results
        combined_data = {
            'target': job.target,
            'cve_analysis': cve_analysis,
            'poc_execution': poc_results,
            'analysis_timestamp': datetime.utcnow().isoformat(),
        }

        phase.data = combined_data
        phase.status = "success"
        phase.updated_at = datetime.utcnow()
        db_session.add(phase)
        db_session.commit()
        db_session.refresh(phase)
        
        print(f"Vulnerability analysis completed. Found {cve_analysis['total_vulns']} vulnerabilities.")
        return phase
        
    except Exception as e:
        phase.data = {"error": str(e)}
        phase.status = "failed"
        phase.updated_at = datetime.utcnow()
        db_session.add(phase)
        db_session.commit()
        db_session.refresh(phase)
        print(f"Vulnerability analysis failed: {str(e)}")
        return phase
