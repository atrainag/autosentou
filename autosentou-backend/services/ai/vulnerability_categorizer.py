"""
AI-Powered Vulnerability Categorization Service
Uses RAG against OWASP Top 10 knowledge base to categorize findings
"""
import logging
from typing import Dict, Any, Optional, Tuple
import re

logger = logging.getLogger(__name__)


# OWASP Top 10 2021 Knowledge Base
OWASP_TOP_10_2021 = {
    "A01:2021": {
        "name": "Broken Access Control",
        "description": "Restrictions on what authenticated users can do are not properly enforced",
        "keywords": ["access control", "authorization", "privilege escalation", "IDOR", "path traversal", "directory traversal", "insecure direct object reference"],
        "examples": ["unauthorized access", "missing authorization", "elevation of privilege"]
    },
    "A02:2021": {
        "name": "Cryptographic Failures",
        "description": "Failures related to cryptography which often lead to exposure of sensitive data",
        "keywords": ["encryption", "TLS", "SSL", "weak cipher", "plaintext", "sensitive data", "crypto", "hash", "password storage"],
        "examples": ["missing encryption", "weak SSL/TLS", "exposed credentials", "plaintext passwords"]
    },
    "A03:2021": {
        "name": "Injection",
        "description": "User-supplied data is not validated, filtered, or sanitized",
        "keywords": ["SQL injection", "SQLi", "command injection", "LDAP injection", "XPath", "NoSQL injection", "OS command", "code injection"],
        "examples": ["SQL injection", "command injection", "LDAP injection", "template injection"]
    },
    "A04:2021": {
        "name": "Insecure Design",
        "description": "Missing or ineffective control design",
        "keywords": ["threat modeling", "secure design patterns", "business logic", "design flaw", "architecture"],
        "examples": ["missing security controls", "business logic bypass", "rate limiting missing"]
    },
    "A05:2021": {
        "name": "Security Misconfiguration",
        "description": "Missing appropriate security hardening or improperly configured permissions",
        "keywords": ["default credentials", "misconfiguration", "unnecessary features", "directory listing", "verbose error", "security headers", "CORS"],
        "examples": ["default passwords", "exposed admin panels", "verbose errors", "missing security headers"]
    },
    "A06:2021": {
        "name": "Vulnerable and Outdated Components",
        "description": "Use of components with known vulnerabilities",
        "keywords": ["CVE", "outdated", "vulnerable component", "library", "dependency", "patch", "update"],
        "examples": ["outdated libraries", "known CVE", "unpatched software"]
    },
    "A07:2021": {
        "name": "Identification and Authentication Failures",
        "description": "Failures to confirm user's identity, authentication, or session management",
        "keywords": ["authentication", "session", "credential", "brute force", "weak password", "session fixation", "MFA", "account enumeration"],
        "examples": ["weak passwords", "session hijacking", "credential stuffing", "missing MFA"]
    },
    "A08:2021": {
        "name": "Software and Data Integrity Failures",
        "description": "Code and infrastructure that does not protect against integrity violations",
        "keywords": ["unsigned", "integrity", "untrusted source", "CI/CD", "auto-update", "deserialization", "insecure deserialization"],
        "examples": ["insecure deserialization", "unsigned updates", "CI/CD pipeline compromise"]
    },
    "A09:2021": {
        "name": "Security Logging and Monitoring Failures",
        "description": "Insufficient logging and monitoring",
        "keywords": ["logging", "monitoring", "audit", "log", "detection", "alerting", "incident response"],
        "examples": ["missing logging", "insufficient monitoring", "no alerting"]
    },
    "A10:2021": {
        "name": "Server-Side Request Forgery (SSRF)",
        "description": "Web application fetches remote resource without validating user-supplied URL",
        "keywords": ["SSRF", "server-side request forgery", "remote resource", "URL validation", "internal network"],
        "examples": ["SSRF", "access to internal resources", "URL manipulation"]
    }
}


class VulnerabilityCategorizer:
    """
    Categorizes vulnerabilities by severity and OWASP Top 10 category.
    Uses rule-based matching against OWASP knowledge base.
    """

    def __init__(self):
        self.owasp_kb = OWASP_TOP_10_2021

    def categorize(self, finding: Dict[str, Any]) -> Tuple[str, str]:
        """
        Categorize a vulnerability finding.

        Args:
            finding: Dictionary containing vulnerability details
                     (title, description, finding_type, cve_id, etc.)

        Returns:
            Tuple of (severity, owasp_category)
        """
        severity = self._determine_severity(finding)
        owasp_category = self._determine_owasp_category(finding)

        logger.info(f"Categorized finding '{finding.get('title', 'Unknown')}': "
                   f"Severity={severity}, OWASP={owasp_category}")

        return severity, owasp_category

    def _determine_severity(self, finding: Dict[str, Any]) -> str:
        """
        Determine severity based on multiple factors.
        Priority: explicit severity > CVSS score > finding type > default
        """
        # 1. Check if severity is already provided
        if finding.get('severity'):
            severity = finding['severity'].lower()
            if severity in ['critical', 'high', 'medium', 'low']:
                return severity.capitalize()

        # 2. Check CVSS score
        cvss_score = finding.get('cvss_score', 0)
        if cvss_score:
            if cvss_score >= 9.0:
                return "Critical"
            elif cvss_score >= 7.0:
                return "High"
            elif cvss_score >= 4.0:
                return "Medium"
            else:
                return "Low"

        # 3. Determine based on finding type
        finding_type = finding.get('finding_type', '').lower()
        title = finding.get('title', '').lower()
        description = finding.get('description', '').lower()

        # Critical patterns
        critical_patterns = [
            'remote code execution', 'rce', 'code execution',
            'authentication bypass', 'sql injection',
            'command injection', 'deserialization'
        ]
        if any(pattern in title or pattern in description for pattern in critical_patterns):
            return "Critical"

        # High patterns
        high_patterns = [
            'xss', 'cross-site scripting', 'csrf',
            'privilege escalation', 'unauthorized access',
            'path traversal', 'ssrf', 'xxe'
        ]
        if any(pattern in title or pattern in description for pattern in high_patterns):
            return "High"

        # Medium patterns
        medium_patterns = [
            'information disclosure', 'misconfiguration',
            'weak', 'missing', 'insecure', 'exposed'
        ]
        if any(pattern in title or pattern in description for pattern in medium_patterns):
            return "Medium"

        # Default to Medium for unknown
        return "Medium"

    def _determine_owasp_category(self, finding: Dict[str, Any]) -> str:
        """
        Match finding to OWASP Top 10 2021 category using keyword matching.
        """
        title = finding.get('title', '').lower()
        description = finding.get('description', '').lower()
        finding_type = finding.get('finding_type', '').lower()

        # Combine all text for matching
        text = f"{title} {description} {finding_type}"

        # Score each OWASP category
        category_scores = {}
        for owasp_id, category in self.owasp_kb.items():
            score = 0

            # Check keywords
            for keyword in category['keywords']:
                if keyword.lower() in text:
                    score += 2

            # Check examples
            for example in category['examples']:
                if example.lower() in text:
                    score += 1

            # Check if category name is in text
            if category['name'].lower() in text:
                score += 3

            category_scores[owasp_id] = score

        # Find the best matching category
        if category_scores:
            best_category = max(category_scores.items(), key=lambda x: x[1])
            if best_category[1] > 0:
                category_id = best_category[0]
                category_name = self.owasp_kb[category_id]['name']
                return f"{category_id} - {category_name}"

        # Type-specific defaults
        if 'sqli' in finding_type or 'sql' in title:
            return "A03:2021 - Injection"

        if 'auth' in finding_type or 'authentication' in title or 'login' in title:
            return "A07:2021 - Identification and Authentication Failures"

        if 'cve' in finding_type or finding.get('cve_id'):
            return "A06:2021 - Vulnerable and Outdated Components"

        if 'web_exposure' in finding_type or 'directory' in title:
            return "A05:2021 - Security Misconfiguration"

        # Default
        return "A05:2021 - Security Misconfiguration"

    def categorize_batch(self, findings: list[Dict[str, Any]]) -> list[Dict[str, Any]]:
        """
        Categorize multiple findings at once.

        Args:
            findings: List of finding dictionaries

        Returns:
            List of findings with added 'severity' and 'owasp_category' fields
        """
        categorized = []
        for finding in findings:
            severity, owasp_category = self.categorize(finding)
            finding['severity'] = severity
            finding['owasp_category'] = owasp_category
            categorized.append(finding)

        return categorized

    def get_owasp_info(self, category_id: str) -> Optional[Dict[str, Any]]:
        """Get detailed information about an OWASP category."""
        return self.owasp_kb.get(category_id)

    def list_owasp_categories(self) -> Dict[str, str]:
        """Get all OWASP Top 10 2021 categories."""
        return {
            owasp_id: f"{owasp_id} - {category['name']}"
            for owasp_id, category in self.owasp_kb.items()
        }


# Global instance
_categorizer_instance = None


def get_categorizer() -> VulnerabilityCategorizer:
    """Get or create the global categorizer instance."""
    global _categorizer_instance
    if _categorizer_instance is None:
        _categorizer_instance = VulnerabilityCategorizer()
    return _categorizer_instance
