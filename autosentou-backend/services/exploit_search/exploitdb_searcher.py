"""
ExploitDB Searcher
Searches local and online ExploitDB for exploits
"""
import subprocess
import json
import logging
import os
import requests
from typing import List, Dict, Any, Optional

logger = logging.getLogger(__name__)


class ExploitDBSearcher:
    """Search ExploitDB (local and online) for exploits."""

    def __init__(self, exploitdb_path: str = "/usr/share/exploitdb"):
        """
        Initialize ExploitDB searcher.

        Args:
            exploitdb_path: Path to local ExploitDB installation
        """
        self.exploitdb_path = exploitdb_path
        self.searchsploit_bin = "searchsploit"
        self.online_api = "https://www.exploit-db.com/search"

        # Check if searchsploit is available
        self.has_searchsploit = self._check_searchsploit()
        if self.has_searchsploit:
            logger.info("ExploitDB searcher initialized with local searchsploit")
        else:
            logger.warning("searchsploit not found, will use online API only")

    def _check_searchsploit(self) -> bool:
        """Check if searchsploit command is available."""
        try:
            result = subprocess.run(
                ['which', self.searchsploit_bin],
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except Exception:
            return False

    def search_exploits(
        self,
        cve_id: Optional[str] = None,
        service: Optional[str] = None,
        version: Optional[str] = None,
        keywords: Optional[List[str]] = None,
        max_results: int = 20
    ) -> List[Dict[str, Any]]:
        """
        Search ExploitDB for exploits.

        Args:
            cve_id: CVE identifier
            service: Service name
            version: Version number
            keywords: Additional keywords
            max_results: Maximum results to return

        Returns:
            List of exploits from ExploitDB
        """
        exploits = []

        # Try local searchsploit first
        if self.has_searchsploit:
            local_results = self._search_local(cve_id, service, version, keywords, max_results)
            exploits.extend(local_results)
            logger.info(f"Found {len(local_results)} local ExploitDB results")

        # If not enough results, try online API
        if len(exploits) < max_results:
            online_results = self._search_online(cve_id, service, version, keywords, max_results - len(exploits))
            exploits.extend(online_results)
            logger.info(f"Found {len(online_results)} online ExploitDB results")

        # Remove duplicates based on EDB-ID
        seen_ids = set()
        unique_exploits = []
        for exploit in exploits:
            edb_id = exploit.get('edb_id', '')
            if edb_id and edb_id not in seen_ids:
                seen_ids.add(edb_id)
                unique_exploits.append(exploit)
            elif not edb_id:
                unique_exploits.append(exploit)

        return unique_exploits[:max_results]

    def _search_local(
        self,
        cve_id: Optional[str],
        service: Optional[str],
        version: Optional[str],
        keywords: Optional[List[str]],
        max_results: int
    ) -> List[Dict[str, Any]]:
        """Search local ExploitDB using searchsploit."""
        try:
            # Build search query
            query_parts = []
            if cve_id:
                query_parts.append(cve_id)
            if service:
                query_parts.append(service)
            if version:
                query_parts.append(version)
            if keywords:
                query_parts.extend(keywords)

            query = ' '.join(query_parts)

            if not query:
                return []

            logger.info(f"Searching local ExploitDB for: {query}")

            # Run searchsploit with JSON output
            cmd = [self.searchsploit_bin, '--json', query]
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode != 0:
                logger.warning(f"searchsploit returned non-zero exit code: {result.returncode}")
                return []

            # Parse JSON output
            try:
                data = json.loads(result.stdout)
            except json.JSONDecodeError:
                logger.error("Failed to parse searchsploit JSON output")
                return []

            exploits = []
            for item in data.get('RESULTS_EXPLOIT', [])[:max_results]:
                exploit = self._parse_searchsploit_result(item)
                exploits.append(exploit)

            return exploits

        except subprocess.TimeoutExpired:
            logger.error("searchsploit command timed out")
            return []
        except Exception as e:
            logger.error(f"Error searching local ExploitDB: {e}", exc_info=True)
            return []

    def _parse_searchsploit_result(self, item: Dict[str, Any]) -> Dict[str, Any]:
        """Parse searchsploit result into standardized format."""
        try:
            title = item.get('Title', '')
            path = item.get('Path', '')
            edb_id = item.get('EDB-ID', '')

            # Extract CVE from title
            import re
            cves = re.findall(r'CVE-\d{4}-\d+', title, re.IGNORECASE)

            # Determine exploit type from title
            exploit_type = 'unknown'
            title_lower = title.lower()
            if 'remote' in title_lower:
                exploit_type = 'remote'
            elif 'local' in title_lower:
                exploit_type = 'local'
            elif 'web' in title_lower:
                exploit_type = 'web'
            elif 'dos' in title_lower:
                exploit_type = 'dos'

            # Determine file type
            file_extension = os.path.splitext(path)[1]
            file_type = file_extension.lstrip('.') if file_extension else 'unknown'

            # Build full local path
            full_path = os.path.join(self.exploitdb_path, path) if path else ''

            return {
                'source': 'exploitdb',
                'edb_id': edb_id,
                'title': title,
                'path': path,
                'full_path': full_path,
                'url': f"https://www.exploit-db.com/exploits/{edb_id}" if edb_id else '',
                'cves': list(set(cves)),
                'exploit_type': exploit_type,
                'file_type': file_type,
                'score': 60  # Base score for ExploitDB (trusted source)
            }
        except Exception as e:
            logger.error(f"Error parsing searchsploit result: {e}")
            return {
                'source': 'exploitdb',
                'error': str(e),
                'title': item.get('Title', ''),
                'score': 0
            }

    def _search_online(
        self,
        cve_id: Optional[str],
        service: Optional[str],
        version: Optional[str],
        keywords: Optional[List[str]],
        max_results: int
    ) -> List[Dict[str, Any]]:
        """
        Search ExploitDB online API.
        Note: This is a simplified implementation. ExploitDB doesn't have an official public API,
        so this would need to be implemented with web scraping or using their search page.
        """
        try:
            # Build search query
            query_parts = []
            if cve_id:
                query_parts.append(cve_id)
            if service:
                query_parts.append(service)
            if version:
                query_parts.append(version)
            if keywords:
                query_parts.extend(keywords)

            query = ' '.join(query_parts)

            if not query:
                return []

            logger.info(f"Searching online ExploitDB for: {query}")

            # This is a placeholder - in reality, you'd need to implement
            # web scraping of exploit-db.com or use a third-party API
            # For now, we'll return empty results
            logger.warning("Online ExploitDB search not fully implemented (requires web scraping)")
            return []

        except Exception as e:
            logger.error(f"Error searching online ExploitDB: {e}")
            return []

    def get_exploit_content(self, edb_id: str) -> Optional[str]:
        """
        Get the content of an exploit by its EDB-ID.
        """
        try:
            if not self.has_searchsploit:
                logger.warning("searchsploit not available")
                return None

            # Use searchsploit to get exploit path
            cmd = [self.searchsploit_bin, '--json', '--id', edb_id]
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode != 0:
                return None

            data = json.loads(result.stdout)
            results = data.get('RESULTS_EXPLOIT', [])

            if not results:
                return None

            path = results[0].get('Path', '')
            if not path:
                return None

            full_path = os.path.join(self.exploitdb_path, path)

            # Read exploit file
            if os.path.exists(full_path):
                with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                    return f.read()
            else:
                logger.warning(f"Exploit file not found: {full_path}")
                return None

        except Exception as e:
            logger.error(f"Error getting exploit content: {e}")
            return None

    def copy_exploit_to_dir(self, edb_id: str, destination_dir: str) -> Optional[str]:
        """
        Copy an exploit to a destination directory.

        Args:
            edb_id: ExploitDB ID
            destination_dir: Directory to copy to

        Returns:
            Path to copied file or None if failed
        """
        try:
            if not self.has_searchsploit:
                return None

            # Use searchsploit -m to copy exploit
            os.makedirs(destination_dir, exist_ok=True)

            cmd = [self.searchsploit_bin, '-m', edb_id]
            result = subprocess.run(
                cmd,
                cwd=destination_dir,
                capture_output=True,
                timeout=10
            )

            if result.returncode != 0:
                logger.error(f"Failed to copy exploit {edb_id}")
                return None

            # Find the copied file
            for file in os.listdir(destination_dir):
                if edb_id in file:
                    return os.path.join(destination_dir, file)

            return None

        except Exception as e:
            logger.error(f"Error copying exploit: {e}")
            return None
