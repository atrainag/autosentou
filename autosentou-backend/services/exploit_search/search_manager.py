"""
Exploit Search Manager
Orchestrates all exploit searchers and provides unified interface
"""
import logging
from typing import List, Dict, Any, Optional
from .github_searcher import GitHubSearcher
from .exploitdb_searcher import ExploitDBSearcher
from .google_searcher import GoogleSearcher

logger = logging.getLogger(__name__)


class ExploitSearchManager:
    """
    Unified interface for searching exploits across multiple sources.
    Orchestrates GitHub, ExploitDB, and Google searchers.
    """

    def __init__(
        self,
        github_token: Optional[str] = None,
        google_api_key: Optional[str] = None,
        google_search_engine_id: Optional[str] = None,
        exploitdb_path: str = "/usr/share/exploitdb"
    ):
        """
        Initialize exploit search manager.

        Args:
            github_token: GitHub API token
            google_api_key: Google Custom Search API key
            google_search_engine_id: Google Custom Search Engine ID
            exploitdb_path: Path to local ExploitDB installation
        """
        self.github_searcher = GitHubSearcher(github_token=github_token)
        self.exploitdb_searcher = ExploitDBSearcher(exploitdb_path=exploitdb_path)
        self.google_searcher = GoogleSearcher(
            api_key=google_api_key,
            search_engine_id=google_search_engine_id
        )

        logger.info("ExploitSearchManager initialized with all searchers")

    def search_all_sources(
        self,
        cve_id: Optional[str] = None,
        service: Optional[str] = None,
        version: Optional[str] = None,
        os: Optional[str] = None,
        keywords: Optional[List[str]] = None,
        max_results_per_source: int = 10
    ) -> Dict[str, List[Dict[str, Any]]]:
        """
        Search all sources for exploits.

        Args:
            cve_id: CVE identifier
            service: Service name
            version: Version number
            os: Operating system
            keywords: Additional search keywords
            max_results_per_source: Maximum results per source

        Returns:
            Dictionary with results from each source
        """
        logger.info(f"Searching all sources for: CVE={cve_id}, Service={service}, Version={version}, OS={os}")

        results = {
            'github': [],
            'exploitdb': [],
            'google': []
        }

        # Search GitHub
        try:
            github_results = self.github_searcher.search_exploits(
                cve_id=cve_id,
                service=service,
                version=version,
                keywords=keywords,
                max_results=max_results_per_source
            )
            results['github'] = github_results
            logger.info(f"GitHub: {len(github_results)} results")
        except Exception as e:
            logger.error(f"GitHub search failed: {e}")

        # Search ExploitDB
        try:
            exploitdb_results = self.exploitdb_searcher.search_exploits(
                cve_id=cve_id,
                service=service,
                version=version,
                keywords=keywords,
                max_results=max_results_per_source
            )
            results['exploitdb'] = exploitdb_results
            logger.info(f"ExploitDB: {len(exploitdb_results)} results")
        except Exception as e:
            logger.error(f"ExploitDB search failed: {e}")

        # Search Google
        try:
            google_results = self.google_searcher.search_exploits(
                cve_id=cve_id,
                service=service,
                version=version,
                keywords=keywords,
                max_results=max_results_per_source
            )
            results['google'] = google_results
            logger.info(f"Google: {len(google_results)} results")
        except Exception as e:
            logger.error(f"Google search failed: {e}")

        return results

    def search_and_rank(
        self,
        cve_id: Optional[str] = None,
        service: Optional[str] = None,
        version: Optional[str] = None,
        os: Optional[str] = None,
        keywords: Optional[List[str]] = None,
        max_results: int = 20
    ) -> List[Dict[str, Any]]:
        """
        Search all sources and return ranked, unified results.

        Args:
            cve_id: CVE identifier
            service: Service name
            version: Version number
            os: Operating system
            keywords: Additional keywords
            max_results: Maximum total results

        Returns:
            Ranked list of exploits from all sources
        """
        # Search all sources
        all_results = self.search_all_sources(
            cve_id=cve_id,
            service=service,
            version=version,
            os=os,
            keywords=keywords,
            max_results_per_source=max_results
        )

        # Combine and rank results
        combined = []

        # Add GitHub results with adjusted scores
        for result in all_results['github']:
            result['adjusted_score'] = result.get('score', 0) * 1.2  # GitHub repos get bonus
            combined.append(result)

        # Add ExploitDB results with adjusted scores
        for result in all_results['exploitdb']:
            result['adjusted_score'] = result.get('score', 0) * 1.5  # ExploitDB is most trusted
            combined.append(result)

        # Add Google results
        for result in all_results['google']:
            result['adjusted_score'] = result.get('score', 0) * 0.8  # Google gets lower weight
            combined.append(result)

        # Remove duplicates based on URL
        seen_urls = set()
        unique_results = []
        for result in combined:
            url = result.get('url') or result.get('html_url', '')
            if url and url not in seen_urls:
                seen_urls.add(url)
                unique_results.append(result)
            elif not url:
                unique_results.append(result)

        # Sort by adjusted score
        unique_results.sort(key=lambda x: x.get('adjusted_score', 0), reverse=True)

        # Add rank
        for i, result in enumerate(unique_results[:max_results], 1):
            result['rank'] = i

        logger.info(f"Ranked {len(unique_results[:max_results])} total exploits")

        return unique_results[:max_results]

    def search_for_cve(self, cve_id: str, max_results: int = 15) -> List[Dict[str, Any]]:
        """
        Simplified method to search for a specific CVE.

        Args:
            cve_id: CVE identifier (e.g., "CVE-2021-41773")
            max_results: Maximum results to return

        Returns:
            Ranked list of exploits
        """
        return self.search_and_rank(
            cve_id=cve_id,
            max_results=max_results
        )

    def search_for_service(
        self,
        service: str,
        version: Optional[str] = None,
        os: Optional[str] = None,
        max_results: int = 15
    ) -> List[Dict[str, Any]]:
        """
        Simplified method to search for service vulnerabilities.

        Args:
            service: Service name (e.g., "Apache", "IIS")
            version: Version number
            os: Operating system
            max_results: Maximum results

        Returns:
            Ranked list of exploits
        """
        return self.search_and_rank(
            service=service,
            version=version,
            os=os,
            keywords=['exploit', 'vulnerability'],
            max_results=max_results
        )

    def get_exploit_details(self, exploit: Dict[str, Any]) -> Dict[str, Any]:
        """
        Get additional details about an exploit.

        Args:
            exploit: Exploit dictionary from search results

        Returns:
            Enhanced exploit information
        """
        source = exploit.get('source')
        details = exploit.copy()

        try:
            if source == 'github':
                # Get README and analyze quality
                repo_full_name = exploit.get('full_name')
                if repo_full_name:
                    quality_analysis = self.github_searcher.analyze_exploit_quality(repo_full_name)
                    details['quality_analysis'] = quality_analysis

            elif source == 'exploitdb':
                # Get exploit content
                edb_id = exploit.get('edb_id')
                if edb_id:
                    content = self.exploitdb_searcher.get_exploit_content(edb_id)
                    if content:
                        details['content_preview'] = content[:500]  # First 500 chars
                        details['content_length'] = len(content)

        except Exception as e:
            logger.error(f"Error getting exploit details: {e}")
            details['details_error'] = str(e)

        return details

    def get_statistics(self) -> Dict[str, Any]:
        """Get statistics about searcher availability."""
        return {
            'github_available': True,  # Always available (can work without token)
            'github_authenticated': self.github_searcher.github_token is not None,
            'exploitdb_available': self.exploitdb_searcher.has_searchsploit,
            'google_api_available': self.google_searcher.api_key is not None,
        }
