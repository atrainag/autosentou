"""
GitHub Exploit Searcher
Searches GitHub for exploit PoCs and repositories
"""
import requests
import logging
import os
import re
from typing import List, Dict, Any, Optional
from datetime import datetime

logger = logging.getLogger(__name__)


class GitHubSearcher:
    """Search GitHub for exploit PoCs and vulnerability research."""

    def __init__(self, github_token: Optional[str] = None):
        """
        Initialize GitHub searcher.

        Args:
            github_token: GitHub personal access token (optional, but recommended for higher rate limits)
        """
        self.github_token = github_token or os.getenv('GITHUB_TOKEN')
        self.api_base = "https://api.github.com"
        self.session = requests.Session()

        # Set headers
        self.session.headers.update({
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'AutoSentou-Pentest-Tool/1.0'
        })

        if self.github_token:
            self.session.headers['Authorization'] = f'token {self.github_token}'
            logger.info("GitHub searcher initialized with authentication")
        else:
            logger.warning("GitHub searcher initialized without token (rate limits apply)")

    def search_exploits(
        self,
        cve_id: Optional[str] = None,
        service: Optional[str] = None,
        version: Optional[str] = None,
        keywords: Optional[List[str]] = None,
        max_results: int = 20
    ) -> List[Dict[str, Any]]:
        """
        Search GitHub for exploits.

        Args:
            cve_id: CVE identifier (e.g., "CVE-2021-41773")
            service: Service name (e.g., "Apache", "IIS")
            version: Version number
            keywords: Additional keywords (e.g., ["exploit", "poc", "rce"])
            max_results: Maximum number of results to return

        Returns:
            List of exploit repositories with metadata
        """
        try:
            # Build search query
            query_parts = []

            if cve_id:
                query_parts.append(cve_id)
            if service:
                query_parts.append(service)
            if version:
                query_parts.append(version)
            if keywords:
                query_parts.extend(keywords)

            # Add exploit-related keywords if not already present
            if not any(k in ['exploit', 'poc', 'vulnerability'] for k in (keywords or [])):
                query_parts.append('exploit OR poc OR vulnerability')

            query = ' '.join(query_parts)

            logger.info(f"Searching GitHub for: {query}")

            # Search repositories
            exploits = self._search_repositories(query, max_results)

            # Search code if CVE provided
            if cve_id and len(exploits) < max_results:
                code_results = self._search_code(cve_id, max_results - len(exploits))
                exploits.extend(code_results)

            # Remove duplicates
            seen_urls = set()
            unique_exploits = []
            for exploit in exploits:
                if exploit['html_url'] not in seen_urls:
                    seen_urls.add(exploit['html_url'])
                    unique_exploits.append(exploit)

            # Sort by relevance (stars + recent activity)
            unique_exploits.sort(key=lambda x: x.get('score', 0), reverse=True)

            logger.info(f"Found {len(unique_exploits)} unique GitHub exploits")
            return unique_exploits[:max_results]

        except Exception as e:
            logger.error(f"Error searching GitHub: {e}", exc_info=True)
            return []

    def _search_repositories(self, query: str, max_results: int) -> List[Dict[str, Any]]:
        """Search GitHub repositories."""
        try:
            url = f"{self.api_base}/search/repositories"
            params = {
                'q': query,
                'sort': 'stars',
                'order': 'desc',
                'per_page': min(max_results, 100)
            }

            response = self.session.get(url, params=params, timeout=30)
            response.raise_for_status()

            data = response.json()
            exploits = []

            for repo in data.get('items', []):
                exploit = self._parse_repository(repo)
                exploits.append(exploit)

            return exploits

        except requests.exceptions.RequestException as e:
            logger.error(f"GitHub API request failed: {e}")
            return []
        except Exception as e:
            logger.error(f"Error parsing GitHub repositories: {e}")
            return []

    def _search_code(self, cve_id: str, max_results: int) -> List[Dict[str, Any]]:
        """Search GitHub code for CVE references."""
        try:
            url = f"{self.api_base}/search/code"
            params = {
                'q': f'"{cve_id}" exploit OR poc',
                'sort': 'indexed',
                'order': 'desc',
                'per_page': min(max_results, 100)
            }

            response = self.session.get(url, params=params, timeout=30)

            # Code search requires authentication
            if response.status_code == 403:
                logger.warning("GitHub code search requires authentication")
                return []

            response.raise_for_status()
            data = response.json()

            exploits = []
            seen_repos = set()

            for item in data.get('items', []):
                repo_full_name = item.get('repository', {}).get('full_name')
                if repo_full_name and repo_full_name not in seen_repos:
                    seen_repos.add(repo_full_name)

                    # Fetch repository details
                    repo_data = self._fetch_repository(repo_full_name)
                    if repo_data:
                        exploit = self._parse_repository(repo_data)
                        exploits.append(exploit)

            return exploits

        except Exception as e:
            logger.error(f"Error searching GitHub code: {e}")
            return []

    def _fetch_repository(self, repo_full_name: str) -> Optional[Dict[str, Any]]:
        """Fetch repository details."""
        try:
            url = f"{self.api_base}/repos/{repo_full_name}"
            response = self.session.get(url, timeout=10)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            logger.error(f"Error fetching repository {repo_full_name}: {e}")
            return None

    def _parse_repository(self, repo: Dict[str, Any]) -> Dict[str, Any]:
        """Parse GitHub repository data into standardized format."""
        try:
            # Calculate relevance score
            stars = repo.get('stargazers_count', 0)
            forks = repo.get('forks_count', 0)
            watchers = repo.get('watchers_count', 0)

            # Check if recently updated (bonus points)
            updated_at = repo.get('updated_at', '')
            try:
                updated_date = datetime.strptime(updated_at, '%Y-%m-%dT%H:%M:%SZ')
                days_since_update = (datetime.now() - updated_date).days
                recency_bonus = max(0, 50 - days_since_update) if days_since_update < 365 else 0
            except:
                recency_bonus = 0

            score = (stars * 2) + (forks * 1.5) + (watchers * 1) + recency_bonus

            # Extract CVEs from description and README
            description = repo.get('description', '') or ''
            cves = re.findall(r'CVE-\d{4}-\d+', description, re.IGNORECASE)

            return {
                'source': 'github',
                'name': repo.get('name', ''),
                'full_name': repo.get('full_name', ''),
                'html_url': repo.get('html_url', ''),
                'clone_url': repo.get('clone_url', ''),
                'git_url': repo.get('git_url', ''),
                'description': description,
                'stars': stars,
                'forks': forks,
                'watchers': watchers,
                'language': repo.get('language', 'Unknown'),
                'created_at': repo.get('created_at', ''),
                'updated_at': updated_at,
                'owner': repo.get('owner', {}).get('login', ''),
                'score': score,
                'cves_mentioned': list(set(cves)),
                'default_branch': repo.get('default_branch', 'main'),
                'size': repo.get('size', 0),
                'topics': repo.get('topics', [])
            }
        except Exception as e:
            logger.error(f"Error parsing repository: {e}")
            return {
                'source': 'github',
                'error': str(e),
                'html_url': repo.get('html_url', ''),
                'score': 0
            }

    def get_readme(self, repo_full_name: str) -> Optional[str]:
        """Fetch README content from repository."""
        try:
            url = f"{self.api_base}/repos/{repo_full_name}/readme"
            response = self.session.get(url, timeout=10)
            response.raise_for_status()

            data = response.json()
            content = data.get('content', '')

            # Decode base64 content
            import base64
            decoded = base64.b64decode(content).decode('utf-8')
            return decoded

        except Exception as e:
            logger.error(f"Error fetching README for {repo_full_name}: {e}")
            return None

    def analyze_exploit_quality(self, repo_full_name: str) -> Dict[str, Any]:
        """
        Analyze exploit repository quality and extract useful information.
        """
        try:
            readme = self.get_readme(repo_full_name)

            analysis = {
                'has_readme': readme is not None,
                'has_usage_instructions': False,
                'has_requirements': False,
                'mentions_poc': False,
                'mentions_tested': False,
                'confidence_score': 0
            }

            if readme:
                readme_lower = readme.lower()

                # Check for usage instructions
                if any(word in readme_lower for word in ['usage', 'how to use', 'install', 'setup']):
                    analysis['has_usage_instructions'] = True
                    analysis['confidence_score'] += 25

                # Check for requirements
                if any(word in readme_lower for word in ['requirements', 'dependencies', 'pip install']):
                    analysis['has_requirements'] = True
                    analysis['confidence_score'] += 20

                # Check for PoC mentions
                if any(word in readme_lower for word in ['poc', 'proof of concept', 'exploit']):
                    analysis['mentions_poc'] = True
                    analysis['confidence_score'] += 30

                # Check if tested
                if any(word in readme_lower for word in ['tested', 'verified', 'working']):
                    analysis['mentions_tested'] = True
                    analysis['confidence_score'] += 25

            return analysis

        except Exception as e:
            logger.error(f"Error analyzing exploit quality: {e}")
            return {'error': str(e), 'confidence_score': 0}
