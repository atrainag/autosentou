"""
Centralized Vulnerability Collection and Statistics

This module provides a single source of truth for vulnerability counting and statistics.
All vulnerability-related counts should be calculated through these functions to ensure consistency.
"""

from typing import Dict, Any, List


def collect_all_vulnerabilities(phases_data: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Canonical function to collect ALL vulnerabilities from all phases.
    This is the SINGLE SOURCE OF TRUTH for vulnerability counts.

    Collects:
    - CVE-based vulnerabilities from vulnerability_analysis phase
    - SQL Injection vulnerabilities from sqli_testing phase
    - Authentication vulnerabilities (account enumeration) from brute_force_testing phase

    Returns:
        List of vulnerability dictionaries, sorted by severity (Critical > High > Medium > Low)
    """
    all_vulns = []

    # 1. From Vulnerability Analysis Phase (CVE-based and exploit-based vulnerabilities)
    vuln_data = phases_data.get('vulnerability_analysis', {})
    if vuln_data:
        for service_vuln in vuln_data.get('vulnerability_results', []):
            for vuln in service_vuln.get('vulnerabilities', []):
                vuln_type = vuln.get('type', 'cve')

                # Check if this is an exploit-based vulnerability
                if vuln_type == 'exploit_available':
                    # Use the pre-defined OWASP category for exploit-based findings
                    owasp_category = vuln.get('owasp_category', 'A06:2021 – Vulnerable and Outdated Components')

                    # Build description with exploit count
                    exploit_count = vuln.get('exploit_count', 0)
                    service_name = service_vuln.get('service', 'Unknown')
                    version = service_vuln.get('version', '')
                    brief_desc = f"Public exploits available ({exploit_count}) for {service_name} {version}"

                    all_vulns.append({
                        'service': service_name,
                        'version': version,
                        'port': service_vuln.get('port', 'N/A'),
                        'severity': vuln.get('severity', 'High'),
                        'owasp_category': owasp_category,
                        'brief_description': brief_desc[:100],
                        'cve_id': 'N/A',
                        'type': 'exploit_available',
                        'source_phase': 'Vulnerability Analysis',
                        'exploit_count': exploit_count,
                        'exploit_evidence': vuln.get('exploit_evidence', []),
                        'full_description': vuln.get('description', ''),
                        'mitigation': vuln.get('mitigation', '')
                    })
                else:
                    # CVE-based vulnerability
                    # Import here to avoid circular import
                    from .vulnerability_report import classify_vulnerability_to_owasp

                    owasp_category = classify_vulnerability_to_owasp(vuln, service_vuln)
                    all_vulns.append({
                        'service': service_vuln.get('service', 'Unknown'),
                        'version': service_vuln.get('version', ''),
                        'port': service_vuln.get('port', 'N/A'),
                        'severity': vuln.get('severity', 'Unknown'),
                        'owasp_category': owasp_category,
                        'brief_description': vuln.get('description', '')[:100],
                        'cve_id': vuln.get('cve_id', 'N/A'),
                        'type': 'cve',
                        'source_phase': 'Vulnerability Analysis',
                        'full_description': vuln.get('description', ''),
                        'mitigation': vuln.get('mitigation', '')
                    })

    # 2. From SQL Injection Testing Phase
    sqli_data = phases_data.get('sqli_testing', {})
    if sqli_data:
        for sqli_result in sqli_data.get('sqli_results', []):
            if sqli_result.get('vulnerable'):
                all_vulns.append({
                    'service': 'Web Application',
                    'port': '80/443',
                    'severity': sqli_result.get('severity', 'High'),
                    'owasp_category': 'A03:2021 – Injection',
                    'brief_description': f"SQL Injection in {sqli_result.get('url', '')}",
                    'cve_id': 'N/A',
                    'type': 'sqli',
                    'source_phase': 'SQL Injection Testing',
                    'url': sqli_result.get('url', '')
                })

    # 3. From Brute Force Testing Phase (account enumeration only)
    bf_data = phases_data.get('brute_force_testing', {}) or phases_data.get('authentication_testing', {})
    if bf_data:
        for login_test in bf_data.get('login_response_tests', []):
            ai_analysis = login_test.get('ai_analysis', {})
            if ai_analysis.get('account_enumeration_possible'):
                # Get severity from AI analysis, default to Medium
                classification = ai_analysis.get('classification', {})
                severity = classification.get('severity', 'Medium')

                all_vulns.append({
                    'service': 'Web Application',
                    'port': '80/443',
                    'severity': severity,
                    'owasp_category': 'A04:2021 – Insecure Design',
                    'brief_description': f"Account Enumeration in {login_test.get('url', '')}",
                    'cve_id': 'N/A',
                    'type': 'authentication',  # Changed from 'account_enum' for clarity
                    'source_phase': 'Authentication Testing',
                    'url': login_test.get('url', '')
                })

    # 4. From Web Enumeration Phase (high-risk findings only)
    web_enum_data = phases_data.get('web_enumeration', {})
    if web_enum_data:
        path_analysis = web_enum_data.get('path_analysis', {})
        analysis = path_analysis.get('analysis', {})
        findings = analysis.get('findings', [])

        # Only count Critical and High risk findings as vulnerabilities
        # Medium/Low are informational and shown separately
        for finding in findings:
            risk = finding.get('risk', '').lower()

            if risk in ['critical', 'high']:
                # Map web enumeration categories to OWASP
                category = finding.get('category', 'Unknown')
                owasp_map = {
                    'Sensitive File': 'A01:2021 – Broken Access Control',
                    'Admin Panel': 'A01:2021 – Broken Access Control',
                    'Configuration File': 'A05:2021 – Security Misconfiguration',
                    'Backup File': 'A05:2021 – Security Misconfiguration',
                    'Development/Debug': 'A05:2021 – Security Misconfiguration',
                    'Information Disclosure': 'A01:2021 – Broken Access Control',
                    'Default Credentials': 'A07:2021 – Identification and Authentication Failures',
                }
                owasp_category = owasp_map.get(category, 'A05:2021 – Security Misconfiguration')

                # Get clean path and description
                clean_path = finding.get('clean_path', finding.get('path', 'Unknown'))
                description = finding.get('description', category)

                all_vulns.append({
                    'service': 'Web Application',
                    'port': '80/443',
                    'severity': risk.capitalize(),  # 'Critical' or 'High'
                    'owasp_category': owasp_category,
                    'brief_description': f"{category}: {clean_path}",
                    'cve_id': 'N/A',
                    'type': 'web_exposure',
                    'source_phase': 'Web Enumeration',
                    'url': clean_path,
                    'category': category,
                    'full_description': description
                })

    # Sort by severity (Critical > High > Medium > Low > Unknown)
    severity_order = {
        'Critical': 0,
        'High': 1,
        'Medium': 2,
        'Low': 3,
        'Informational': 4,
        'Unknown': 5
    }
    all_vulns.sort(key=lambda x: (severity_order.get(x['severity'], 5), x['service']))

    return all_vulns


def calculate_vulnerability_statistics(all_vulns: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Calculate comprehensive statistics from the canonical vulnerability list.

    This ensures all counts are consistent across the entire report.

    Args:
        all_vulns: List of vulnerabilities from collect_all_vulnerabilities()

    Returns:
        Dictionary containing all vulnerability statistics
    """
    total = len(all_vulns)

    # Count by severity
    critical_count = sum(1 for v in all_vulns if v['severity'] == 'Critical')
    high_count = sum(1 for v in all_vulns if v['severity'] == 'High')
    medium_count = sum(1 for v in all_vulns if v['severity'] == 'Medium')
    low_count = sum(1 for v in all_vulns if v['severity'] == 'Low')
    info_count = sum(1 for v in all_vulns if v['severity'] in ['Informational', 'Info'])
    unknown_count = sum(1 for v in all_vulns if v['severity'] == 'Unknown')

    # Combined counts
    critical_high_count = critical_count + high_count
    medium_low_count = medium_count + low_count

    # Count by type
    cve_count = sum(1 for v in all_vulns if v['type'] == 'cve')
    exploit_available_count = sum(1 for v in all_vulns if v['type'] == 'exploit_available')
    sqli_count = sum(1 for v in all_vulns if v['type'] == 'sqli')
    auth_count = sum(1 for v in all_vulns if v['type'] == 'authentication')
    web_exposure_count = sum(1 for v in all_vulns if v['type'] == 'web_exposure')

    # Count by OWASP category
    owasp_counts = {}
    for vuln in all_vulns:
        owasp_cat = vuln.get('owasp_category', 'Uncategorized')
        owasp_counts[owasp_cat] = owasp_counts.get(owasp_cat, 0) + 1

    # Top OWASP categories (sorted by count)
    top_owasp = sorted(owasp_counts.items(), key=lambda x: x[1], reverse=True)[:5]

    return {
        # Total counts
        'total_vulnerabilities': total,

        # By severity
        'critical': critical_count,
        'high': high_count,
        'medium': medium_count,
        'low': low_count,
        'informational': info_count,
        'unknown': unknown_count,

        # Combined severity
        'critical_high': critical_high_count,
        'medium_low': medium_low_count,

        # By type
        'by_type': {
            'cve': cve_count,
            'exploit_available': exploit_available_count,
            'sqli': sqli_count,
            'authentication': auth_count,
            'web_exposure': web_exposure_count,
        },

        # By OWASP
        'by_owasp': owasp_counts,
        'top_owasp_categories': top_owasp,

        # Percentages (for reporting)
        'critical_percentage': round((critical_count / total * 100), 1) if total > 0 else 0,
        'high_percentage': round((high_count / total * 100), 1) if total > 0 else 0,
        'medium_percentage': round((medium_count / total * 100), 1) if total > 0 else 0,
        'low_percentage': round((low_count / total * 100), 1) if total > 0 else 0,
    }


def get_vulnerability_summary(phases_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Convenience function that returns both vulnerabilities and statistics.

    This is the main function to use when you need vulnerability data for reporting.

    Args:
        phases_data: Dictionary containing all phase data

    Returns:
        Dictionary with:
        - 'vulnerabilities': List of all vulnerabilities
        - 'statistics': Dictionary of statistics
        - 'has_vulnerabilities': Boolean indicating if any vulnerabilities exist
    """
    all_vulns = collect_all_vulnerabilities(phases_data)
    stats = calculate_vulnerability_statistics(all_vulns)

    return {
        'vulnerabilities': all_vulns,
        'statistics': stats,
        'has_vulnerabilities': len(all_vulns) > 0
    }


def format_vulnerability_summary_text(stats: Dict[str, Any]) -> str:
    """
    Generate a human-readable summary of vulnerability statistics.

    Args:
        stats: Statistics dictionary from calculate_vulnerability_statistics()

    Returns:
        Formatted string summary
    """
    lines = []

    total = stats['total_vulnerabilities']

    if total == 0:
        return "No vulnerabilities identified during this assessment."

    lines.append(f"Total of {total} vulnerabilities identified:")

    if stats['critical'] > 0:
        lines.append(f"  - {stats['critical']} Critical")
    if stats['high'] > 0:
        lines.append(f"  - {stats['high']} High")
    if stats['medium'] > 0:
        lines.append(f"  - {stats['medium']} Medium")
    if stats['low'] > 0:
        lines.append(f"  - {stats['low']} Low")

    # Type breakdown
    by_type = stats['by_type']
    lines.append(f"\nBreakdown by type:")
    if by_type['cve'] > 0:
        lines.append(f"  - {by_type['cve']} CVE-based vulnerabilities")
    if by_type.get('exploit_available', 0) > 0:
        lines.append(f"  - {by_type['exploit_available']} Outdated components with public exploits")
    if by_type['sqli'] > 0:
        lines.append(f"  - {by_type['sqli']} SQL Injection vulnerabilities")
    if by_type['authentication'] > 0:
        lines.append(f"  - {by_type['authentication']} Authentication vulnerabilities")
    if by_type['web_exposure'] > 0:
        lines.append(f"  - {by_type['web_exposure']} Web exposure vulnerabilities")

    return '\n'.join(lines)
