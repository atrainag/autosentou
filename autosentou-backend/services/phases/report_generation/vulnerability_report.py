"""
Vulnerability Report Generation

Generates master vulnerability table, OWASP summary, and detailed findings.
"""

from typing import Dict, Any, List
from services.ai.ai_service import init_ai_service
from .markdown_utils import sanitize_table_cell, safe_truncate
from .vulnerability_utils import get_vulnerability_summary

ai_service = init_ai_service()


def generate_vulnerability_sections(phases_data: Dict[str, Any]) -> str:
    """
    Generate all vulnerability-related sections:
    - Master Vulnerability Table
    - OWASP TOP 10 Summary
    - Information Gathering
    - Detailed Vulnerability Findings
    """
    lines = []

    vuln_data = phases_data.get('vulnerability_analysis', {})
    info_data = phases_data.get('information_gathering', {})

    # Debug: print vulnerability data structure
    print(f"[DEBUG] generate_vulnerability_sections - vuln_data keys: {list(vuln_data.keys()) if vuln_data else 'None'}")
    if vuln_data:
        vuln_results = vuln_data.get('vulnerability_results', [])
        print(f"[DEBUG] vulnerability_results count: {len(vuln_results)}")

        # Also check service_analysis for comparison
        service_analysis = vuln_data.get('service_analysis', {})
        services = service_analysis.get('services', [])
        print(f"[DEBUG] service_analysis.services count: {len(services)}")

        if services:
            total_cves_in_services = sum(len(s.get('cves_found', [])) for s in services)
            print(f"[DEBUG] Total CVEs in service_analysis.services: {total_cves_in_services}")

        for i, vr in enumerate(vuln_results):
            vulns = vr.get('vulnerabilities', [])
            print(f"[DEBUG]   Service {i}: {vr.get('service')} - {len(vulns)} vulnerabilities")
            for v in vulns:
                print(f"[DEBUG]     - Type: {v.get('type')}, Severity: {v.get('severity')}")
    else:
        print(f"[DEBUG] vuln_data is empty or None")
    
    if not vuln_data and not info_data:
        return ""
    
    # 3.0 Master Vulnerability Table (comes first after exec summary)
    master_table = generate_master_vulnerability_table(phases_data)
    lines.append(master_table)
    lines.append("\n")
    
    # 3.1 OWASP TOP 10 Summary (right after master table)
    owasp_summary = generate_owasp_summary_table(phases_data)
    if owasp_summary:
        lines.append(owasp_summary)
        lines.append("\n")
    
    # 3.2 Information Gathering
    if info_data:
        info_section = generate_information_gathering_section(info_data)
        lines.append(info_section)
        lines.append("\n")
    
    # 3.3 Detailed Vulnerability Findings
    if vuln_data:
        detailed_vulns = generate_detailed_vulnerability_findings(vuln_data)
        lines.append(detailed_vulns)
    
    return ''.join(lines)


def generate_master_vulnerability_table(phases_data: Dict[str, Any]) -> str:
    """
    Generate master vulnerability summary table grouped by OWASP category.
    """
    lines = []
    lines.append("### Master Vulnerability Table\n")

    # Get canonical vulnerability data
    vuln_summary = get_vulnerability_summary(phases_data)
    all_vulns = vuln_summary['vulnerabilities']
    stats = vuln_summary['statistics']

    # Add statistics summary header
    if not all_vulns:
        lines.append("*No vulnerabilities identified during this assessment.*\n")
        return ''.join(lines)

    # Show summary statistics before the table
    lines.append(f"**Total Vulnerabilities:** {stats['total_vulnerabilities']} ")
    lines.append(f"(Critical: {stats['critical']}, ")
    lines.append(f"High: {stats['high']}, ")
    lines.append(f"Medium: {stats['medium']}, ")
    lines.append(f"Low: {stats['low']})\n\n")

    lines.append("The following table provides a detailed overview of all identified vulnerabilities grouped by OWASP category:\n\n")

    # Group vulnerabilities by OWASP category
    owasp_groups = {}
    for vuln in all_vulns:
        owasp_cat = vuln.get('owasp_category', 'Uncategorized')
        if owasp_cat not in owasp_groups:
            owasp_groups[owasp_cat] = []
        owasp_groups[owasp_cat].append(vuln)

    # Sort OWASP categories by severity (most critical first)
    def get_category_priority(cat_vulns):
        severity_scores = {'Critical': 4, 'High': 3, 'Medium': 2, 'Low': 1, 'Unknown': 0}
        max_severity = max(severity_scores.get(v.get('severity', 'Unknown'), 0) for v in cat_vulns)
        return (-max_severity, -len(cat_vulns))

    sorted_categories = sorted(owasp_groups.items(), key=lambda x: get_category_priority(x[1]))

    vuln_counter = 1

    for owasp_cat, vulns in sorted_categories:
        # OWASP Category Header
        lines.append(f"#### {owasp_cat}\n\n")

        # Create table for this category
        lines.append("| ID | Severity | Affected Service/URL | Port | Description |\n")
        lines.append("|-----|----------|---------------------|------|-------------|\n")

        for vuln in vulns:
            vuln_id = sanitize_table_cell(f"VULN-{vuln_counter:03d}")
            severity = sanitize_table_cell(vuln.get('severity', 'Unknown'))

            # Determine affected service/URL
            if vuln.get('url'):
                affected = sanitize_table_cell(vuln.get('url', ''), max_length=35)
            elif vuln.get('service'):
                service = vuln.get('service', 'Unknown')
                version = vuln.get('version', '')
                affected = sanitize_table_cell(f"{service} {version}".strip(), max_length=35)
            else:
                affected = sanitize_table_cell('Unknown', max_length=35)

            port = sanitize_table_cell(str(vuln.get('port', 'N/A')))
            description = safe_truncate(vuln.get('brief_description', ''), max_length=60, truncate_after_pipes=True)

            lines.append(f"| {vuln_id} | {severity} | {affected} | {port} | {description} |\n")
            vuln_counter += 1

        lines.append("\n")

    return ''.join(lines)


# NOTE: collect_all_vulnerabilities() is defined in vulnerability_utils.py
# Do NOT duplicate it here - use the import from vulnerability_utils


def classify_vulnerability_to_owasp(vuln: Dict[str, Any], service_info: Dict[str, Any]) -> str:
    """
    Classify vulnerability into OWASP TOP 10 2021 using keyword-based matching.

    OPTIMIZATION: Disabled AI classification to avoid rate limits.
    - Web Analysis phase already provides AI-powered OWASP classification
    - CVE-based vulnerabilities are reliably classified via keyword matching
    - Eliminates 50+ API calls per report (was causing rate limit failures)
    """
    # SKIP AI - use keyword-based classification directly
    # This is faster, more reliable, and avoids rate limits
    return fallback_owasp_classification(vuln, service_info)


def fallback_owasp_classification(vuln: Dict[str, Any], service_info: Dict[str, Any]) -> str:
    """
    Hardcoded fallback OWASP classification based on keywords.
    """
    # Check if OWASP category is already set (e.g., for exploit-based vulns)
    if vuln.get('owasp_category'):
        return vuln.get('owasp_category')

    # Check vulnerability type
    vuln_type = vuln.get('type', '')
    if vuln_type == 'exploit_available':
        return 'A06:2021 – Vulnerable and Outdated Components'

    description = vuln.get('description', '').lower()
    cve_id = vuln.get('cve_id', '').lower()

    # Keyword mapping
    if any(kw in description for kw in ['sql injection', 'sqli', 'injection']):
        return 'A03:2021 – Injection'
    elif any(kw in description for kw in ['outdated', 'vulnerable version', 'cve-', 'public exploit', 'exploit available']):
        return 'A06:2021 – Vulnerable and Outdated Components'
    elif any(kw in description for kw in ['authentication', 'password', 'login', 'session']):
        return 'A07:2021 – Identification and Authentication Failures'
    elif any(kw in description for kw in ['access control', 'authorization', 'privilege']):
        return 'A01:2021 – Broken Access Control'
    elif any(kw in description for kw in ['misconfiguration', 'default', 'configuration']):
        return 'A05:2021 – Security Misconfiguration'
    elif any(kw in description for kw in ['xss', 'cross-site scripting']):
        return 'A03:2021 – Injection'
    elif any(kw in description for kw in ['crypto', 'encryption', 'ssl', 'tls']):
        return 'A02:2021 – Cryptographic Failures'
    else:
        return 'Uncategorized'


def generate_owasp_summary_table(phases_data: Dict[str, Any]) -> str:
    """
    Generate OWASP TOP 10 summary table with vulnerability counts.
    """
    lines = []
    lines.append("### OWASP TOP 10 2021 Distribution\n")
    lines.append("The following OWASP TOP 10 2021 categories were identified in this assessment:\n\n")

    # Get canonical vulnerability data
    vuln_summary = get_vulnerability_summary(phases_data)
    stats = vuln_summary['statistics']

    if not vuln_summary['has_vulnerabilities']:
        return ""

    # Use OWASP counts from centralized statistics
    owasp_counts = stats['by_owasp']
    
    # OWASP descriptions
    owasp_descriptions = {
        'A01:2021 – Broken Access Control': 'Access control failures allowing unauthorized access',
        'A02:2021 – Cryptographic Failures': 'Weaknesses in cryptography leading to data exposure',
        'A03:2021 – Injection': 'Injection flaws such as SQL, NoSQL, OS command injection',
        'A04:2021 – Insecure Design': 'Design flaws and missing security controls',
        'A05:2021 – Security Misconfiguration': 'Insecure default configurations and settings',
        'A06:2021 – Vulnerable and Outdated Components': 'Using components with known vulnerabilities',
        'A07:2021 – Identification and Authentication Failures': 'Broken authentication and session management',
        'A08:2021 – Software and Data Integrity Failures': 'Integrity violations in software and data',
        'A09:2021 – Security Logging and Monitoring Failures': 'Insufficient logging and monitoring',
        'A10:2021 – Server-Side Request Forgery (SSRF)': 'SSRF vulnerabilities',
        'Uncategorized': 'Vulnerabilities not fitting standard OWASP categories'
    }
    
    # Create table
    lines.append("| OWASP Category | Description | Vulnerabilities Found |\n")
    lines.append("|----------------|-------------|-----------------------|\n")
    
    # Sort by count (descending)
    sorted_categories = sorted(owasp_counts.items(), key=lambda x: x[1], reverse=True)
    
    for owasp_cat, count in sorted_categories:
        description = owasp_descriptions.get(owasp_cat, 'Unknown category')
        owasp_cat_safe = sanitize_table_cell(owasp_cat, max_length=50)
        description_safe = sanitize_table_cell(description, max_length=60)
        lines.append(f"| {owasp_cat_safe} | {description_safe} | {count} |\n")
    
    lines.append("\n**Full OWASP TOP 10 2021 Documentation**: https://owasp.org/Top10/\n")
    
    return ''.join(lines)


def generate_information_gathering_section(info_data: Dict[str, Any]) -> str:
    """
    Generate Information Gathering section with comprehensive reconnaissance data.
    """
    lines = []
    lines.append("### Information Gathering\n")

    is_local_target = info_data.get('is_local_target', False)

    # Nmap results summary
    nmap_data = info_data.get('nmap', {})
    if nmap_data:
        lines.append("#### Port Scan Summary\n")
        open_ports = nmap_data.get('open_ports_count', 0)
        lines.append(f"**Total Open Ports**: {open_ports}\n")

        # Host information
        host_info = nmap_data.get('host_info', {})
        if host_info:
            ip = host_info.get('ip', 'N/A')
            hostname = host_info.get('hostname', 'N/A')
            if ip != 'N/A':
                lines.append(f"**IP Address**: {ip}\n")
            if hostname != 'N/A' and hostname != ip:
                lines.append(f"**Hostname**: {hostname}\n")

        lines.append("\n")

        # Top services summary (only show open ports)
        parsed_ports = nmap_data.get('parsed_ports', [])
        open_ports_only = [p for p in parsed_ports if p.get('state') == 'open']

        if open_ports_only and len(open_ports_only) > 0:
            lines.append("**Top Discovered Services**:\n\n")
            lines.append("| Port | State | Service | Version |\n")
            lines.append("|------|-------|---------|----------|\n")

            # Show top 10 open ports
            for port in open_ports_only[:10]:
                port_num = sanitize_table_cell(port.get('port', 'N/A'))
                state = sanitize_table_cell(port.get('state', 'Unknown'))
                service = sanitize_table_cell(port.get('service', 'Unknown'))
                version = safe_truncate(port.get('version', ''), max_length=40, truncate_after_pipes=True)
                lines.append(f"| {port_num} | {state} | {service} | {version} |\n")

            if len(open_ports_only) > 10:
                lines.append(f"\n*{len(open_ports_only) - 10} additional open ports found. See Section 2.5 for complete details.*\n")

            lines.append("\n")

    # OS Detection Summary
    os_detection = nmap_data.get('os_detection', {}) if nmap_data else {}
    if os_detection and not os_detection.get('skipped'):
        os_matches = os_detection.get('os_matches', [])
        if os_matches and len(os_matches) > 0:
            lines.append("#### Operating System Detection\n")
            best_match = os_matches[0]
            lines.append(f"**Most Likely OS**: {best_match.get('name', 'Unknown')} ({best_match.get('accuracy', 'N/A')}% confidence)\n\n")

    # WHOIS/DNS (only for public targets)
    if not is_local_target:
        whois_data = info_data.get('whois', {})
        if whois_data and not whois_data.get('skipped'):
            parsed_whois = whois_data.get('parsed', {})
            if parsed_whois:
                lines.append("#### Domain Information (WHOIS)\n")
                lines.append(f"**Registrar**: {parsed_whois.get('registrar', 'N/A')}\n")
                lines.append(f"**Creation Date**: {parsed_whois.get('creation_date', 'N/A')}\n")
                lines.append(f"**Expiration Date**: {parsed_whois.get('expiration_date', 'N/A')}\n")

                registrant = parsed_whois.get('registrant', {})
                if registrant:
                    org = registrant.get('organization', 'N/A')
                    if org != 'N/A':
                        lines.append(f"**Organization**: {org}\n")

                lines.append("\n")

        # DNS Enumeration
        dnsenum_data = info_data.get('dnsenum', {})
        if dnsenum_data and not dnsenum_data.get('skipped'):
            parsed_dns = dnsenum_data.get('parsed', {})
            if parsed_dns:
                lines.append("#### DNS Enumeration\n")

                # Name servers
                nameservers = parsed_dns.get('nameservers', [])
                if nameservers:
                    lines.append(f"**Name Servers**: {', '.join(nameservers)}\n")

                # Mail servers
                mail_servers = parsed_dns.get('mail_servers', [])
                if mail_servers:
                    lines.append(f"**Mail Servers**: {', '.join(mail_servers)}\n")

                # Subdomains
                subdomains = parsed_dns.get('subdomains', [])
                if subdomains:
                    lines.append(f"**Subdomains Found**: {len(subdomains)}\n")
                    if len(subdomains) <= 5:
                        for subdomain in subdomains:
                            lines.append(f"  - {subdomain}\n")
                    else:
                        for subdomain in subdomains[:5]:
                            lines.append(f"  - {subdomain}\n")
                        lines.append(f"  - *...and {len(subdomains) - 5} more*\n")

                lines.append("\n")
    else:
        lines.append("#### Domain Information\n")
        lines.append("**Skipped** - Target is a local/private network address. WHOIS and DNS enumeration are not applicable.\n\n")

    return ''.join(lines)


def generate_detailed_vulnerability_findings(vuln_data: Dict[str, Any]) -> str:
    """
    Generate detailed vulnerability findings with individual VULN-XXX entries.
    """
    lines = []
    lines.append("### Detailed Vulnerability Findings\n")
    
    vuln_results = vuln_data.get('vulnerability_results', [])
    
    if not vuln_results:
        lines.append("*No detailed vulnerabilities to report.*\n")
        return ''.join(lines)
    
    vuln_counter = 1
    
    for service_vuln in vuln_results:
        if service_vuln.get('vulnerabilities'):
            for vuln in service_vuln.get('vulnerabilities', []):
                lines.append(generate_individual_vulnerability_detail(
                    vuln_counter, 
                    vuln, 
                    service_vuln
                ))
                vuln_counter += 1
    
    return ''.join(lines)


def generate_individual_vulnerability_detail(
    vuln_id: int,
    vuln: Dict[str, Any],
    service_info: Dict[str, Any]
) -> str:
    """
    Generate detailed entry for a single vulnerability.
    """
    lines = []

    vuln_id_str = f"VULN-{vuln_id:03d}"
    vuln_type = vuln.get('type', 'cve')

    # Determine vulnerability name based on type
    if vuln_type == 'exploit_available':
        vuln_name = f"Public Exploits Available for {service_info.get('service', 'Unknown')} {service_info.get('version', '')}"
    else:
        vuln_name = vuln.get('cve_id', f"Vulnerability in {service_info.get('service', 'Unknown')}")

    lines.append(f"#### {vuln_id_str}: {vuln_name}\n\n")

    # Classification
    if vuln_type == 'exploit_available':
        owasp_category = vuln.get('owasp_category', 'A06:2021 – Vulnerable and Outdated Components')
    else:
        owasp_category = classify_vulnerability_to_owasp(vuln, service_info)

    lines.append(f"**OWASP Category**: {owasp_category}\n")
    lines.append(f"**Severity**: {vuln.get('severity', 'Unknown')}\n")
    lines.append(f"**Affected Service**: {service_info.get('service', 'Unknown')} {service_info.get('version', '')} (Port {service_info.get('port', 'N/A')})\n")

    # Related CVEs
    cve_id = vuln.get('cve_id', 'N/A')
    if cve_id != 'N/A':
        lines.append(f"**Related CVEs**: {cve_id}\n")
    else:
        lines.append(f"**Related CVEs**: N/A\n")

    # Technical Risk
    lines.append("\n**Technical Risk**\n\n")
    technical_risk = generate_technical_risk_description(vuln, service_info)
    lines.append(f"{technical_risk}\n")

    # Evidence section - different handling for exploit-based vs CVE-based
    lines.append("\n**Evidence**\n\n")

    if vuln_type == 'exploit_available':
        # Exploit-based vulnerability evidence
        lines.append(f"**Detection Method**: \n")
        lines.append(f"1. Service version identified via Nmap service detection scan\n")
        lines.append(f"2. Public exploits discovered through automated search of:\n")
        lines.append(f"   - ExploitDB (Offensive Security's exploit database)\n")
        lines.append(f"   - GitHub Security Advisories and exploit repositories\n")
        lines.append(f"   - Google Custom Search for security research\n\n")

        lines.append(f"**Identified Service**: {service_info.get('service', 'Unknown')} {service_info.get('version', '')}\n")
        lines.append(f"**Port**: {service_info.get('port', 'N/A')}\n")
        lines.append(f"**Protocol**: TCP\n\n")

        exploit_evidence = vuln.get('exploit_evidence', [])
        exploit_count = vuln.get('exploit_count', len(exploit_evidence))

        if exploit_evidence:
            lines.append(f"**Public Exploits Found** ({exploit_count} total):\n\n")
            lines.append("The following publicly available exploits were identified for this exact service version:\n\n")
            lines.append("| Source | Title | Type | Link |\n")
            lines.append("|--------|-------|------|------|\n")

            for exploit in exploit_evidence[:5]:  # Show top 5
                source = exploit.get('source', 'Unknown')
                title = exploit.get('title', 'Unknown')[:50]  # Truncate long titles
                exploit_type = exploit.get('exploit_type', 'unknown')
                url = exploit.get('url', '')
                edb_id = exploit.get('edb_id', '')

                # Format link
                if url:
                    link = f"[Link]({url})"
                elif edb_id:
                    link = f"[EDB-{edb_id}](https://www.exploit-db.com/exploits/{edb_id})"
                else:
                    link = "N/A"

                lines.append(f"| {source} | {title} | {exploit_type} | {link} |\n")

            if exploit_count > 5:
                lines.append(f"\n*...and {exploit_count - 5} more exploits found*\n")
        else:
            lines.append(f"**Exploit Count**: {exploit_count} public exploit(s) found\n")

        lines.append(f"\n**Assessment Notes**: {vuln.get('description', 'Multiple publicly available exploits exist for this service version, indicating it is actively targeted by attackers.')}\n")
    else:
        # CVE-based vulnerability evidence
        lines.append(f"**Detection Method**: \n")
        lines.append(f"1. Service version identified via Nmap service detection scan\n")
        lines.append(f"2. CVE information retrieved from National Vulnerability Database (NVD)\n")
        lines.append(f"3. Automated matching against NVD API for known vulnerabilities\n\n")

        lines.append(f"**Identified Service**: {service_info.get('service', 'Unknown')} {service_info.get('version', '')}\n")
        lines.append(f"**Port**: {service_info.get('port', 'N/A')}\n")
        lines.append(f"**Protocol**: TCP\n\n")

        if cve_id != 'N/A':
            lines.append(f"**CVE Information from NVD**:\n\n")
            lines.append(f"- **CVE ID**: {cve_id}\n")
            lines.append(f"- **Description**: {vuln.get('description', 'No description available')}\n")
            lines.append(f"- **Source**: National Vulnerability Database (NVD) - https://nvd.nist.gov/\n")

            # Add CVSS score if available
            cvss_score = vuln.get('cvss_score')
            if cvss_score:
                lines.append(f"- **CVSS Score**: {cvss_score}\n")

            lines.append(f"\n**Note**: This CVE was automatically matched to the service version detected during the Nmap scan. The vulnerability information is sourced from the official NVD database maintained by NIST.\n")
        else:
            lines.append(f"{vuln.get('description', 'No detailed evidence available.')}\n")

    # Remediation
    lines.append("\n**Remediation**\n\n")
    if vuln.get('mitigation'):
        lines.append(f"{vuln.get('mitigation')}\n")
    else:
        lines.append("- Update to the latest stable version\n")
        lines.append("- Review security advisories for the affected service\n")
        lines.append("- Implement security best practices\n")

    # References
    lines.append("\n**References**\n\n")
    lines.append(f"- OWASP: https://owasp.org/Top10/\n")
    if cve_id != 'N/A':
        lines.append(f"- NVD: https://nvd.nist.gov/vuln/detail/{cve_id}\n")
    if vuln_type == 'exploit_available':
        lines.append(f"- ExploitDB: https://www.exploit-db.com/\n")
        lines.append(f"- GitHub Security Advisories: https://github.com/advisories\n")

    lines.append("\n---\n\n")

    return ''.join(lines)


def generate_technical_risk_description(vuln: Dict[str, Any], service_info: Dict[str, Any]) -> str:
    """
    Generate technical risk description using severity-based templates.

    OPTIMIZATION: Disabled AI to avoid rate limits (was 1 API call per vulnerability).
    Uses severity-based templates instead - faster and more consistent.
    """
    # SKIP AI - use template-based approach
    severity = vuln.get('severity', 'Unknown').upper()
    service = service_info.get('service', 'the service')
    version = service_info.get('version', '')
    vuln_type = vuln.get('type', 'cve')

    # Special handling for exploit-based vulnerabilities
    if vuln_type == 'exploit_available':
        exploit_count = vuln.get('exploit_count', 0)
        if severity == 'CRITICAL':
            return f"This {service} {version} has {exploit_count} publicly available exploit(s), including remote code execution capabilities. Attackers can readily use these exploits to gain complete system control. Immediate update is critical."
        elif severity == 'HIGH':
            return f"This {service} {version} has {exploit_count} publicly available exploit(s). The existence of working exploits significantly increases the risk of successful attacks. Prompt remediation is strongly recommended."
        else:
            return f"This {service} {version} has {exploit_count} publicly available exploit(s). While these may have limited impact, the availability of working exploits makes this an attractive target for attackers."

    # CVE-based vulnerability templates
    if severity == 'CRITICAL':
        return f"This critical vulnerability in {service} could allow attackers to gain complete system control or access sensitive data. Immediate remediation is required."
    elif severity == 'HIGH':
        return f"This high-severity vulnerability in {service} could be exploited to compromise system security or access unauthorized resources."
    elif severity == 'MEDIUM':
        return f"This medium-severity vulnerability in {service} may allow attackers to partially compromise security or gain limited unauthorized access."
    elif severity == 'LOW':
        return f"This low-severity vulnerability in {service} presents a minor security risk that should be addressed as part of routine hardening."
    else:
        return f"This vulnerability in {service} poses a security risk to the system and should be reviewed."