"""
Vulnerability Report Generation

Generates master vulnerability table, OWASP summary, and detailed findings.
"""

from typing import Dict, Any, List
from services.ai.ai_service import init_ai_service
from .markdown_utils import sanitize_table_cell, safe_truncate
from .vulnerability_utils import get_vulnerability_summary

ai_service = init_ai_service()


def generate_vulnerability_sections(phases_data: Dict[str, Any]) -> str:
    """
    Generate all vulnerability-related sections:
    - Master Vulnerability Table
    - OWASP TOP 10 Summary
    - Information Gathering
    - Detailed Vulnerability Findings
    """
    lines = []
    
    vuln_data = phases_data.get('vulnerability_analysis', {})
    info_data = phases_data.get('information_gathering', {})
    
    if not vuln_data and not info_data:
        return ""
    
    # 3.0 Master Vulnerability Table (comes first after exec summary)
    master_table = generate_master_vulnerability_table(phases_data)
    lines.append(master_table)
    lines.append("\n")
    
    # 3.1 OWASP TOP 10 Summary (right after master table)
    owasp_summary = generate_owasp_summary_table(phases_data)
    if owasp_summary:
        lines.append(owasp_summary)
        lines.append("\n")
    
    # 3.2 Information Gathering
    if info_data:
        info_section = generate_information_gathering_section(info_data)
        lines.append(info_section)
        lines.append("\n")
    
    # 3.3 Detailed Vulnerability Findings
    if vuln_data:
        detailed_vulns = generate_detailed_vulnerability_findings(vuln_data)
        lines.append(detailed_vulns)
    
    return ''.join(lines)


def generate_master_vulnerability_table(phases_data: Dict[str, Any]) -> str:
    """
    Generate master vulnerability summary table with statistics header.
    """
    lines = []
    lines.append("### Master Vulnerability Table\n")

    # Get canonical vulnerability data
    vuln_summary = get_vulnerability_summary(phases_data)
    all_vulns = vuln_summary['vulnerabilities']
    stats = vuln_summary['statistics']

    # Add statistics summary header
    if not all_vulns:
        lines.append("*No vulnerabilities identified during this assessment.*\n")
        return ''.join(lines)

    # Show summary statistics before the table
    lines.append(f"**Total Vulnerabilities:** {stats['total_vulnerabilities']} ")
    lines.append(f"(Critical: {stats['critical']}, ")
    lines.append(f"High: {stats['high']}, ")
    lines.append(f"Medium: {stats['medium']}, ")
    lines.append(f"Low: {stats['low']})\n\n")

    lines.append("The following table provides a detailed overview of all identified vulnerabilities:\n\n")
    
    # Create table
    lines.append("| ID | OWASP Category | Severity | Affected Service | Port | Brief Description |\n")
    lines.append("|-----|----------------|----------|------------------|------|-------------------|\n")
    
    for idx, vuln in enumerate(all_vulns, 1):
        vuln_id = sanitize_table_cell(f"VULN-{idx:03d}")
        owasp_cat = sanitize_table_cell(vuln.get('owasp_category', 'Uncategorized'), max_length=40)
        severity = sanitize_table_cell(vuln.get('severity', 'Unknown'))
        service = sanitize_table_cell(vuln.get('service', 'Unknown'), max_length=25)
        port = sanitize_table_cell(vuln.get('port', 'N/A'))
        description = safe_truncate(vuln.get('brief_description', ''), max_length=80, truncate_after_pipes=True)

        lines.append(f"| {vuln_id} | {owasp_cat} | {severity} | {service} | {port} | {description} |\n")
    
    return ''.join(lines)


def collect_all_vulnerabilities(phases_data: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Collect and classify all vulnerabilities from all phases.
    Group by severity first, then by service.
    """
    all_vulns = []
    
    # From Vulnerability Analysis
    vuln_data = phases_data.get('vulnerability_analysis', {})
    if vuln_data:
        for service_vuln in vuln_data.get('vulnerability_results', []):
            for vuln in service_vuln.get('vulnerabilities', []):
                owasp_category = classify_vulnerability_to_owasp(vuln, service_vuln)
                all_vulns.append({
                    'service': service_vuln.get('service', 'Unknown'),
                    'port': service_vuln.get('port', 'N/A'),
                    'severity': vuln.get('severity', 'Unknown'),
                    'owasp_category': owasp_category,
                    'brief_description': vuln.get('description', '')[:100],
                    'cve_id': vuln.get('cve_id', 'N/A'),
                    'type': 'vulnerability_analysis'
                })
    
    # From SQL Injection Testing
    sqli_data = phases_data.get('sqli_testing', {})
    if sqli_data:
        for sqli_result in sqli_data.get('sqli_results', []):
            if sqli_result.get('vulnerable'):
                all_vulns.append({
                    'service': 'Web Application',
                    'port': '80/443',
                    'severity': sqli_result.get('severity', 'High'),
                    'owasp_category': 'A03:2021 – Injection',
                    'brief_description': f"SQL Injection in {sqli_result.get('url', '')}",
                    'cve_id': 'N/A',
                    'type': 'sqli'
                })
    
    # From Brute Force Testing (account enumeration)
    bf_data = phases_data.get('brute_force_testing', {})
    if bf_data:
        for login_test in bf_data.get('login_response_tests', []):
            ai_analysis = login_test.get('ai_analysis', {})
            if ai_analysis.get('account_enumeration_possible'):
                all_vulns.append({
                    'service': 'Web Application',
                    'port': '80/443',
                    'severity': 'Medium',
                    'owasp_category': 'A04:2021 – Insecure Design',
                    'brief_description': f"Account Enumeration in {login_test.get('url', '')}",
                    'cve_id': 'N/A',
                    'type': 'account_enum'
                })
    
    # Sort by severity (Critical > High > Medium > Low)
    severity_order = {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3, 'Unknown': 4}
    all_vulns.sort(key=lambda x: (severity_order.get(x['severity'], 4), x['service']))
    
    return all_vulns


def classify_vulnerability_to_owasp(vuln: Dict[str, Any], service_info: Dict[str, Any]) -> str:
    """
    Use AI to classify vulnerability into OWASP TOP 10 2021.
    Falls back to hardcoded mapping if AI fails.
    """
    try:
        prompt = f"""
Classify this vulnerability into the OWASP TOP 10 2021 framework:

Vulnerability Description: {vuln.get('description', '')}
Service: {service_info.get('service', '')} {service_info.get('version', '')}
CVE: {vuln.get('cve_id', 'N/A')}
Severity: {vuln.get('severity', '')}

Choose the MOST APPROPRIATE category from:
- A01:2021 – Broken Access Control
- A02:2021 – Cryptographic Failures
- A03:2021 – Injection
- A04:2021 – Insecure Design
- A05:2021 – Security Misconfiguration
- A06:2021 – Vulnerable and Outdated Components
- A07:2021 – Identification and Authentication Failures
- A08:2021 – Software and Data Integrity Failures
- A09:2021 – Security Logging and Monitoring Failures
- A10:2021 – Server-Side Request Forgery (SSRF)

Respond with ONLY the category code and name (e.g., "A03:2021 – Injection").
If uncertain, respond with "Uncategorized".
"""
        
        owasp_category = ai_service.generate(prompt).strip()
        
        # Validate response
        if 'A0' in owasp_category and '2021' in owasp_category:
            return owasp_category
        else:
            return fallback_owasp_classification(vuln, service_info)
    
    except Exception as e:
        print(f"AI classification failed: {e}, using fallback")
        return fallback_owasp_classification(vuln, service_info)


def fallback_owasp_classification(vuln: Dict[str, Any], service_info: Dict[str, Any]) -> str:
    """
    Hardcoded fallback OWASP classification based on keywords.
    """
    description = vuln.get('description', '').lower()
    cve_id = vuln.get('cve_id', '').lower()
    
    # Keyword mapping
    if any(kw in description for kw in ['sql injection', 'sqli', 'injection']):
        return 'A03:2021 – Injection'
    elif any(kw in description for kw in ['outdated', 'vulnerable version', 'cve-']):
        return 'A06:2021 – Vulnerable and Outdated Components'
    elif any(kw in description for kw in ['authentication', 'password', 'login', 'session']):
        return 'A07:2021 – Identification and Authentication Failures'
    elif any(kw in description for kw in ['access control', 'authorization', 'privilege']):
        return 'A01:2021 – Broken Access Control'
    elif any(kw in description for kw in ['misconfiguration', 'default', 'configuration']):
        return 'A05:2021 – Security Misconfiguration'
    elif any(kw in description for kw in ['xss', 'cross-site scripting']):
        return 'A03:2021 – Injection'
    elif any(kw in description for kw in ['crypto', 'encryption', 'ssl', 'tls']):
        return 'A02:2021 – Cryptographic Failures'
    else:
        return 'Uncategorized'


def generate_owasp_summary_table(phases_data: Dict[str, Any]) -> str:
    """
    Generate OWASP TOP 10 summary table with vulnerability counts.
    """
    lines = []
    lines.append("### OWASP TOP 10 2021 Distribution\n")
    lines.append("The following OWASP TOP 10 2021 categories were identified in this assessment:\n\n")

    # Get canonical vulnerability data
    vuln_summary = get_vulnerability_summary(phases_data)
    stats = vuln_summary['statistics']

    if not vuln_summary['has_vulnerabilities']:
        return ""

    # Use OWASP counts from centralized statistics
    owasp_counts = stats['by_owasp']
    
    # OWASP descriptions
    owasp_descriptions = {
        'A01:2021 – Broken Access Control': 'Access control failures allowing unauthorized access',
        'A02:2021 – Cryptographic Failures': 'Weaknesses in cryptography leading to data exposure',
        'A03:2021 – Injection': 'Injection flaws such as SQL, NoSQL, OS command injection',
        'A04:2021 – Insecure Design': 'Design flaws and missing security controls',
        'A05:2021 – Security Misconfiguration': 'Insecure default configurations and settings',
        'A06:2021 – Vulnerable and Outdated Components': 'Using components with known vulnerabilities',
        'A07:2021 – Identification and Authentication Failures': 'Broken authentication and session management',
        'A08:2021 – Software and Data Integrity Failures': 'Integrity violations in software and data',
        'A09:2021 – Security Logging and Monitoring Failures': 'Insufficient logging and monitoring',
        'A10:2021 – Server-Side Request Forgery (SSRF)': 'SSRF vulnerabilities',
        'Uncategorized': 'Vulnerabilities not fitting standard OWASP categories'
    }
    
    # Create table
    lines.append("| OWASP Category | Description | Vulnerabilities Found |\n")
    lines.append("|----------------|-------------|-----------------------|\n")
    
    # Sort by count (descending)
    sorted_categories = sorted(owasp_counts.items(), key=lambda x: x[1], reverse=True)
    
    for owasp_cat, count in sorted_categories:
        description = owasp_descriptions.get(owasp_cat, 'Unknown category')
        owasp_cat_safe = sanitize_table_cell(owasp_cat, max_length=50)
        description_safe = sanitize_table_cell(description, max_length=60)
        lines.append(f"| {owasp_cat_safe} | {description_safe} | {count} |\n")
    
    lines.append("\n**Full OWASP TOP 10 2021 Documentation**: https://owasp.org/Top10/\n")
    
    return ''.join(lines)


def generate_information_gathering_section(info_data: Dict[str, Any]) -> str:
    """
    Generate Information Gathering section with comprehensive reconnaissance data.
    """
    lines = []
    lines.append("### Information Gathering\n")

    is_local_target = info_data.get('is_local_target', False)

    # Nmap results summary
    nmap_data = info_data.get('nmap', {})
    if nmap_data:
        lines.append("#### Port Scan Summary\n")
        open_ports = nmap_data.get('open_ports_count', 0)
        lines.append(f"**Total Open Ports**: {open_ports}\n")

        # Host information
        host_info = nmap_data.get('host_info', {})
        if host_info:
            ip = host_info.get('ip', 'N/A')
            hostname = host_info.get('hostname', 'N/A')
            if ip != 'N/A':
                lines.append(f"**IP Address**: {ip}\n")
            if hostname != 'N/A' and hostname != ip:
                lines.append(f"**Hostname**: {hostname}\n")

        lines.append("\n")

        # Top services summary (only show open ports)
        parsed_ports = nmap_data.get('parsed_ports', [])
        open_ports_only = [p for p in parsed_ports if p.get('state') == 'open']

        if open_ports_only and len(open_ports_only) > 0:
            lines.append("**Top Discovered Services**:\n\n")
            lines.append("| Port | State | Service | Version |\n")
            lines.append("|------|-------|---------|----------|\n")

            # Show top 10 open ports
            for port in open_ports_only[:10]:
                port_num = sanitize_table_cell(port.get('port', 'N/A'))
                state = sanitize_table_cell(port.get('state', 'Unknown'))
                service = sanitize_table_cell(port.get('service', 'Unknown'))
                version = safe_truncate(port.get('version', ''), max_length=40, truncate_after_pipes=True)
                lines.append(f"| {port_num} | {state} | {service} | {version} |\n")

            if len(open_ports_only) > 10:
                lines.append(f"\n*{len(open_ports_only) - 10} additional open ports found. See Section 2.5 for complete details.*\n")

            lines.append("\n")

    # OS Detection Summary
    os_detection = nmap_data.get('os_detection', {}) if nmap_data else {}
    if os_detection and not os_detection.get('skipped'):
        os_matches = os_detection.get('os_matches', [])
        if os_matches and len(os_matches) > 0:
            lines.append("#### Operating System Detection\n")
            best_match = os_matches[0]
            lines.append(f"**Most Likely OS**: {best_match.get('name', 'Unknown')} ({best_match.get('accuracy', 'N/A')}% confidence)\n\n")

    # WHOIS/DNS (only for public targets)
    if not is_local_target:
        whois_data = info_data.get('whois', {})
        if whois_data and not whois_data.get('skipped'):
            parsed_whois = whois_data.get('parsed', {})
            if parsed_whois:
                lines.append("#### Domain Information (WHOIS)\n")
                lines.append(f"**Registrar**: {parsed_whois.get('registrar', 'N/A')}\n")
                lines.append(f"**Creation Date**: {parsed_whois.get('creation_date', 'N/A')}\n")
                lines.append(f"**Expiration Date**: {parsed_whois.get('expiration_date', 'N/A')}\n")

                registrant = parsed_whois.get('registrant', {})
                if registrant:
                    org = registrant.get('organization', 'N/A')
                    if org != 'N/A':
                        lines.append(f"**Organization**: {org}\n")

                lines.append("\n")

        # DNS Enumeration
        dnsenum_data = info_data.get('dnsenum', {})
        if dnsenum_data and not dnsenum_data.get('skipped'):
            parsed_dns = dnsenum_data.get('parsed', {})
            if parsed_dns:
                lines.append("#### DNS Enumeration\n")

                # Name servers
                nameservers = parsed_dns.get('nameservers', [])
                if nameservers:
                    lines.append(f"**Name Servers**: {', '.join(nameservers)}\n")

                # Mail servers
                mail_servers = parsed_dns.get('mail_servers', [])
                if mail_servers:
                    lines.append(f"**Mail Servers**: {', '.join(mail_servers)}\n")

                # Subdomains
                subdomains = parsed_dns.get('subdomains', [])
                if subdomains:
                    lines.append(f"**Subdomains Found**: {len(subdomains)}\n")
                    if len(subdomains) <= 5:
                        for subdomain in subdomains:
                            lines.append(f"  - {subdomain}\n")
                    else:
                        for subdomain in subdomains[:5]:
                            lines.append(f"  - {subdomain}\n")
                        lines.append(f"  - *...and {len(subdomains) - 5} more*\n")

                lines.append("\n")
    else:
        lines.append("#### Domain Information\n")
        lines.append("**Skipped** - Target is a local/private network address. WHOIS and DNS enumeration are not applicable.\n\n")

    return ''.join(lines)


def generate_detailed_vulnerability_findings(vuln_data: Dict[str, Any]) -> str:
    """
    Generate detailed vulnerability findings with individual VULN-XXX entries.
    """
    lines = []
    lines.append("### Detailed Vulnerability Findings\n")
    
    vuln_results = vuln_data.get('vulnerability_results', [])
    
    if not vuln_results:
        lines.append("*No detailed vulnerabilities to report.*\n")
        return ''.join(lines)
    
    vuln_counter = 1
    
    for service_vuln in vuln_results:
        if service_vuln.get('vulnerabilities'):
            for vuln in service_vuln.get('vulnerabilities', []):
                lines.append(generate_individual_vulnerability_detail(
                    vuln_counter, 
                    vuln, 
                    service_vuln
                ))
                vuln_counter += 1
    
    return ''.join(lines)


def generate_individual_vulnerability_detail(
    vuln_id: int, 
    vuln: Dict[str, Any], 
    service_info: Dict[str, Any]
) -> str:
    """
    Generate detailed entry for a single vulnerability.
    """
    lines = []
    
    vuln_id_str = f"VULN-{vuln_id:03d}"
    vuln_name = vuln.get('cve_id', f"Vulnerability in {service_info.get('service', 'Unknown')}")
    
    lines.append(f"#### {vuln_id_str}: {vuln_name}\n\n")
    
    # Classification
    owasp_category = classify_vulnerability_to_owasp(vuln, service_info)
    lines.append(f"**OWASP Category**: {owasp_category}\n")
    lines.append(f"**Severity**: {vuln.get('severity', 'Unknown')}\n")
    lines.append(f"**Affected Service**: {service_info.get('service', 'Unknown')} {service_info.get('version', '')} (Port {service_info.get('port', 'N/A')})\n")
    
    # Related CVEs
    cve_id = vuln.get('cve_id', 'N/A')
    if cve_id != 'N/A':
        lines.append(f"**Related CVEs**: {cve_id}\n")
    else:
        lines.append(f"**Related CVEs**: N/A\n")
    
    # Technical Risk (AI-generated, 1-2 sentences)
    lines.append("\n**Technical Risk**\n\n")
    technical_risk = generate_technical_risk_description(vuln, service_info)
    lines.append(f"{technical_risk}\n")
    
    # Evidence (show CVE details if available)
    lines.append("\n**Evidence**\n\n")
    lines.append(f"**Detection Method**: Version fingerprinting via Nmap service scan\n\n")
    
    if cve_id != 'N/A':
        lines.append(f"**Service Banner**: {service_info.get('service', 'Unknown')} {service_info.get('version', '')}\n\n")
        lines.append(f"**Known CVEs**:\n")
        lines.append(f"- {cve_id}: {vuln.get('description', 'No description available')}\n")
    else:
        lines.append(f"{vuln.get('description', 'No detailed evidence available.')}\n")
    
    # Remediation
    lines.append("\n**Remediation**\n\n")
    if vuln.get('mitigation'):
        lines.append(f"{vuln.get('mitigation')}\n")
    else:
        lines.append("- Update to the latest stable version\n")
        lines.append("- Review security advisories for the affected service\n")
        lines.append("- Implement security best practices\n")
    
    # References
    lines.append("\n**References**\n\n")
    lines.append(f"- OWASP: https://owasp.org/Top10/\n")
    if cve_id != 'N/A':
        lines.append(f"- NVD: https://nvd.nist.gov/vuln/detail/{cve_id}\n")
    
    lines.append("\n---\n\n")
    
    return ''.join(lines)


def generate_technical_risk_description(vuln: Dict[str, Any], service_info: Dict[str, Any]) -> str:
    """
    Generate AI-powered technical risk description (1-2 sentences).
    """
    try:
        prompt = f"""
In 1-2 sentences, explain the technical risk of this vulnerability:

Vulnerability: {vuln.get('description', 'Unknown')}
Service: {service_info.get('service', 'Unknown')} {service_info.get('version', '')}
Severity: {vuln.get('severity', 'Unknown')}

Focus ONLY on the technical danger (e.g., "Allows remote code execution", "Enables database access").
Do NOT mention business impact.
Keep it concise and technical.
"""
        
        risk_text = ai_service.generate(prompt).strip()
        return risk_text if risk_text else "This vulnerability poses a security risk to the system."
    
    except Exception as e:
        # Fallback
        return f"This {vuln.get('severity', 'Unknown').lower()}-severity vulnerability in {service_info.get('service', 'the service')} could be exploited by attackers."